A model of RAPM ( Based on devel version 7 ) The model works by iteratively selecting features and rules and internally generating rewards when the features are new features ( previously unexamined ) or when the rules lead to a success ( a rule is found that explains the patterns ) . The general solution algorithm is ( START ) Raven s Problem Pick Feature -------------------+--------+ +-----------+----+---...-------+ Feature 1 Feature 2 ... Feature X Select Find Prev. Solution Found / No Yes No / Long time Yes ( DONE ) +-------------- Pick Rule vv +-------+--+--...----+ Rule 1 Rule 2 ... Rule Y Verify Rule Verified / +------------------------- No Yes ---------+ The D1/D2 competition --------------------- This is a complete rethinking of the competing productions algorithm described in Stocco ( 2017 ) and Stocco et al. ( 2017 ) . In essence 1 . There are no more "dont" productions. 2 . Competition is managed between "pick" productions using the conflict set. 3 The one production that fires sees its utility updated with a positive ( reward * D1 ) value. 4 . Productions in the conflict set that did not fire are udpated with a negative ( D2 * reward ) value. In the future the conflict set should be detected automatically. Here it is derived from the prefix and pathway of a production. ( clear-all ) ( written-for-act-r-version "7.4.0" )  define-model bar ( sgp style-warnings nil model-warnings nil style-warnings nil auto-attend t er t ans 0.05 record-ticks nil esc t mas 8.0 bll nil blc 100.0 Assumes all chunks are incredibly active lf 0.01 ul t reward-hook bg-reward-hook-anticorrelated alpha 0.05 egs 0.01 imaginal-activation 10 visual-activation 10 trace-filter production-firing-only ) CHUNK TYPES Chunk types. Not needed... but they save lots of warnings. ( chunk-type ( rapm-screen ( include visual-object ) ) kind id ) ( chunk-type ( rapm-cell ( include visual-object ) ) kind row column row-num column-num problem phase shape number background texture feature0 feature1 feature2 feature3 feature4 feature5 feature6 feature7 feature8 feature9 ) ( chunk-type ( rapm-cell-location ( include visual-location ) ) row column row-num column-num problem shape number background texture feature0 feature1 feature2 feature3 feature4 feature5 feature6 feature7 feature8 feature9 ) ( chunk-type ( rapm-screen-location ( include visual-location ) ) id ) ( chunk-type sketchpad nature verified problem ) ( chunk-type rapm-goal step routine problem direction span direction-num span-num ) ( chunk-type missing-cell kind nature pid ) ( chunk-type feature kind feature ) ( chunk-type solution problem feature rule direction predicted-value ) ( chunk-type rule kind same different progression name ) ( chunk-type direction kind direction span direction-num span-num ) DECLARATIVE MEMORY A list of chunks in DM. ( add-dm ( rapm-cell isa chunk ) ( rapm-problem isa chunk ) ( rapm-pause isa chunk ) ( rapm-choice isa chunk ) The coordinates ( row0-col0 isa chunk ) ( row0-col1 isa chunk ) ( row0-col2 isa chunk ) ( row1-col0 isa chunk ) ( row1-col1 isa chunk ) ( row1-col2 isa chunk ) ( row2-col0 isa chunk ) ( row2-col1 isa chunk ) ( row2-col2 isa chunk ) Goal states ( verify isa chunk ) ( examine isa chunk ) ( collect isa chunk ) ( find-rule isa chunk ) ( choice isa chunk ) ( check isa chunk ) ( start isa chunk ) ( generate isa chunk ) Simple chunks ( yes isa chunk ) ( no isa chunk ) ( zero isa chunk ) ( one isa chunk ) ( two isa chunk ) ( three isa chunk ) ( pause1 isa chunk ) ( pause2 isa chunk ) ( done isa chunk ) ( problem isa chunk ) ( nothing isa chunk ) ( missing-cell isa chunk ) ( sketchpad isa chunk ) Features and values ( feature isa chunk ) ( shape isa chunk ) ( triangle isa chunk ) ( square isa chunk ) ( circle isa chunk ) ( diamond isa chunk ) ( number isa chunk ) ( texture isa chunk ) ( solid isa chunk ) ( transparent isa chunk ) ( dotted isa chunk ) ( striped isa chunk ) ( size isa chunk ) ( small isa chunk ) ( medium isa chunk ) ( large isa chunk ) Slot names ( row isa chunk ) ( row-num isa chunk ) ( column isa chunk ) ( column-num isa chunk ) ( same isa chunk ) ( solution isa chunk ) Feature chunks ( shape-feature isa feature kind feature feature shape ) ( number-feature isa feature kind feature feature number ) ( texture-feature isa feature kind feature feature texture ) ( background-feature isa feature kind feature feature background ) ( orientation-feature isa feature kind feature feature orientation ) Rules ( same-rule isa rule kind rule name same same possible progression nil different nil ) ( progression-rule isa rule kind rule name progression same nil progression possible different possible ) ( constant-rule isa rule kind rule name constant same possible progression possible different possible ) ( disjoint-rule isa rule kind rule name disjoint same nil progression possible different possible ) ) ---------------------------------------------------------------- START ---------------------------------------------------------------- General solution algorithm 1 . Pick a feature. 2 . Retrieve a solution for that feature. 3 . If you cannot find a solution associated to that feature examine the feature ( randomly going column or row ) . 4 . If you can find a solution then check 4.1 If it s been a long time since you have found a new feature end 4.2 If not go back to 1 Pick Feature ------+ Find Solution Found / No Yes No / Mark Time Long time *EXAMINE* Yes *END* ------------------------------------------------------------------ ( p start*attend-problem "Attends a problem" goal buffer empty visual-location buffer empty +visual-location kind rapm-problem ) ( p start*create-goal goal buffer empty visual kind rapm-problem id PID +goal isa rapm-goal step start kind rapm-problem problem PID +visual-location kind rapm-cell screen-x lowest screen-y lowest +temporal isa time ticks 0 Cleans up the reward signals eval ( trigger-reward nil ) ) ---------------------------------------------------------------- 1.1 FEATURE SELECTION ---------------------------------------------------------------- This is the crucial part .- "      " -. /  .-. .-. /  "=._     | )(__/  \__)( |     _.="  / "=._" . / / . "_.="  "=._ (_     ^^     _)" . "
;;;                 " / "
;;;                _.=" IIIIII/ "=._
;;;      _     _.=" . "\  " IIII "  /" . "=._     _
;;;     ( \_.=" . "     `--------`     " . "=._/ )
;;;      > _.="  Retrieves a feature  Retrieves a feature  Retrieves a feature  Retrieves a feature  Retrieves a feature  Retrieves a feature  Retrieves a feature  Retrieves a feature  When only one feature is left select it  When only one feature is left select it  Feature A  Once a feature has been picked examine whether a solution exists  If a solution has been found and time has passed proceed  If a solution has been found and time has not passed back to selecting  If a previous solution cannot be found initiate the process of finding one by row  If a previous solution cannot be found initiate the process of finding one by column  Collects the value of a feature while scanning horizontally  Collects the values of a feature vertically  Rule to be suggested when a feauture remains the same  Rule to be suggested when a feauture increases  Rule to be suggested when a feauture increases  Very neutral. Accepts any suggestion  After verifying one cell moves in the same direction ( indicated by SPAN ) to the next one  If I am looking at a new cell make it the focus of verification  Notes when an entire line satisfies a rule  Notes when an entire line satisfies a rule  When a cell is not verified by the rule forget and go to start  Memorizes the solution and resets the temporal counter  Prepare the imaginal buffer to generate a predicted missing cell  Prepare the imaginal buffer to generate a predicted missing cell  Begin the collection process during the generation of a solution  Begins the collection process during the generation of a solution  Predicts the value of the missing cell based a rule. Uses Lisp code  When no more solution rules can be retrieved we are done  Done with the generation switches to responding  When the options show up prepare to respond  When the solution has been found put it in the imaginal buffer  When we have a solution scan the available options  When we have scanned all the options we retrieve the most similar  Responds with index to a cell with column index 0  Responds with middle finger to a cell with column index 1  Responds with ring finger to a cell with column index 2  Responds with pinkie finger to a cell with column index 3  When no solution has been found pick one at random  Neatly stops ACT-R when the screen says done  Reloads the model and sets up the experiment ( and optionally prints the visicon ) <EOF>